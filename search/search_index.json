{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#loading-the-firmware","title":"Loading the Firmware","text":"<ol> <li>You will need to download the latest micropython version to load onto the Raspberry Pi Pico W. Ensure you grab the latest build and not a preview build.</li> </ol> <ol> <li>Place your Raspberry Pi Pico into the breadboard to protect the pins and your fingers.</li> <li>Hold down the BOOTSEL button on the raspberry Pi Pico</li> </ol> <ol> <li>Connect the Pi Pico to the USB cable connected to you laptop.</li> <li>When the drive is displayed in Windows Explorer or Mac Finder copy the uf2 file from step 1 onto the Pi Pico drive.</li> <li>If this was successful the drive will disappear as the device has been reset ready for use.</li> </ol>"},{"location":"#your-first-program","title":"Your First Program","text":"<p>We will be using VSCode so ensure you have that installed. </p> <ol> <li>Disconnect the Pi Pico from your laptop.</li> <li>Download the VSCode profile for the Pi Pico from VSCode Setup Repo, RP Pico.code-profile by clicking on the <code>Download raw file</code> icon.</li> <li>Follow the instructions here to import it into VSCode</li> <li>You should now see a new icon on the left called <code>Raspberry Pi Pico Project</code> </li> <li>Connect the Pi Pico to your laptop</li> <li>Click on it and select <code>New MicroPython Project</code> </li> <li>Give your project a name <code>Blinky</code> and change the location to where you want the project to be created. </li> <li>Click <code>Create</code> to create your new Pi Pico project</li> <li>If everything has gone smoothly you should have a new project that looks like the below image. </li> <li>You should see that the Pico is connected and you can click on the run icon in the bottom left position to run the code python conde in <code>blink.py</code> on the Pi Pico.</li> </ol>"},{"location":"accelerometer/accelerometer/","title":"Accelerometer &amp; Gyroscope","text":"<p>These can be used together to measure both linear acceleration and angular velocity. They can be used for gimbals (think of a camera stabiliser), self balancing robots, gaming controllers, smartphones, drones, motion detection like someone falling over, VR headsets, and more.</p>"},{"location":"accelerometer/accelerometer/#what-is-an-accelerometer","title":"What is an Accelerometer?","text":"<p>An accelerometer is an electronic device that measures acceleration, which is defined as the rate of change of velocity with respect to time.</p>"},{"location":"accelerometer/accelerometer/#what-is-a-gyroscope","title":"What is a Gyroscope?","text":"<p>A gyroscope is an electronic device that measures angular velocity, which is defined as the rate of change of orientation with respect to time. </p>"},{"location":"accelerometer/accelerometer/#pitch-roll-and-yaw","title":"Pitch, Roll and Yaw","text":"<p>These are the three angles that describe the orientation of an object in 3D space. They are commonly used in robotics and aerospace applications. They are measured in degrees or radians. </p> <p></p> <p>Roll:</p> <ul> <li>Roll refers to rotation about the vertical axis passing through an object's center of mass.</li> <li>It is often compared to the motion when you tilt your head from side to side.</li> <li>In aviation or aerospace, a positive roll indicates a banking action where one wing rises relative to the other.</li> </ul> <p>Yaw:</p> <ul> <li>Yaw refers to rotation about the horizontal axis passing through an object's center of mass.</li> <li>It is similar to the motion when you turn your head from left to right.</li> <li>In aviation or aerospace, yaw indicates a change in direction of flight along the horizontal plane.</li> </ul> <p>Pitch:</p> <ul> <li>Pitch refers to rotation about the longitudinal axis passing through an object's center of mass.</li> <li>It is often compared to the motion when you tilt your body forward or backward.</li> <li>In aviation or aerospace, pitch is the angle between the nose of the aircraft and a horizontal line.</li> </ul>"},{"location":"accelerometer/accelerometer/#mp6050","title":"MP6050","text":"<p>The MP6050 is a popular 6-axis Motion Tracking Device which can also be called an inertial measurement unit (IMU). It has both a gyroscope and accelerometer built into it. This gives the device the ability to measure both linear acceleration and angular velocity.</p> <p>It also has a built in digital temperature sensor that can be used for temperature compensation.</p> <p></p>"},{"location":"accelerometer/accelerometer/#features","title":"Features","text":"<p>The MP6050 has the following features:</p> <ul> <li>Accel Range: \u00b12g, \u00b14g, \u00b18g, \u00b116g</li> <li>Gyro Range: \u00b1250\u00b0/s, \u00b1500\u00b0/s, \u00b11000\u00b0/s, \u00b12000\u00b0/s</li> <li>Temperature Sensor: Measures temperature in \u00b0C with a resolution of 0.5\u00b0C</li> <li>I2C Interface: Supports I2C communication at up to 400 kHz</li> <li>SPI Interface: Supports SPI communication at up to 10 MHz</li> <li>Interrupt Pin: Can generate interrupts for various events such as data ready and motion detection.</li> </ul>"},{"location":"accelerometer/accelerometer/#pinout","title":"Pinout","text":"<p>Here is a pinout table for the MPU-6050 sensor:</p> Pin Number Pin Name Description 1 VCC Power supply, typically +3.3V or +5V 2 GND Ground 3 SDA (SDIO) I2C serial data line 4 SCL (SCLK) I2C serial clock line 5 XDA Used to interface other I2C sensors with the MPU-6050 6 XCL Used to interface other I2C sensors with the MPU-6050 7 AD0 Use this pin to change the I2C address 8 INT Interrupt pin \u2013 can be used to indicate that new measurement data is available"},{"location":"accelerometer/activities/motion_detection/","title":"Motion Detection","text":""},{"location":"accelerometer/activities/motion_detection/#simulation","title":"Simulation","text":"<p>We will be using an MP6050 which is 6-axis Motion Tracking Device which can also be called an inertial measurement unit (IMU). It has both a gyroscope and accelerometer built into it.</p> <p>View the Raspberry Pi Pico on Wokwi that has been setup with an MPU6050. </p> <ul> <li>You should see a Pi Pico connected to the MP6050 and 2 LEDs.  </li> </ul> <p>Activity</p> <ol> <li> <p>Read the code and predict what will happen when you run the simulation.</p> </li> <li> <p>Run the simulation and click on the MP6050 to alter the pitch of the device (x-rotation). </p> </li> <li> <p>Why do the LEDs change?</p> </li> <li>Modify the code to handle y or z rotation?</li> <li>The data is being displayed in the output window of Wokwi or when you run it on your device. Change the output to display as comma separated values. Take a copy of the output and paste it into a spreadsheet to analyse the data. What do you notice?</li> <li>Using the supplied mechatronics kit build the motion detection system. Test it out! Step by step instructions are below</li> </ol>"},{"location":"accelerometer/activities/motion_detection/#building-the-motion-detection-system","title":"Building the Motion Detection System","text":""},{"location":"accelerometer/activities/motion_detection/#materials","title":"Materials","text":"<ul> <li>Pi Pico x1</li> <li>MP6050 x1</li> <li>Breadboard and jumper wires</li> <li>LEDs x2</li> <li>220 ohm resistors x2</li> </ul> <p>Note</p> <ul> <li>Red wires are power</li> <li>Black wires are ground</li> <li>Other coloured wires are signals</li> </ul>"},{"location":"accelerometer/activities/motion_detection/#step-1-pico-and-mpu6050","title":"Step 1: Pico and MPU6050","text":"<ul> <li>Attach the Pi Pico and the MP6050 sensor to the terminal strip of the breadboard. </li> </ul>"},{"location":"accelerometer/activities/motion_detection/#step-2-led-connection","title":"Step 2: LED Connection","text":"<ul> <li>Insert the LEDs into the breadboard. The cathode (longer leg) should be connected to a GPIO pin on the Pi Pico and the anode (shorter leg) should be connected to a resistor, which is then connected to ground. The resistors are used to limit the current flowing through the LED, which prevents it from burning out. </li> </ul> GPIO Pin LED Cathode Resistor Ground 18 Green 220 ohm (\u03a9) GND 19 Blue 220 ohm (\u03a9) GND <p>Note</p> <ul> <li>The black ground wire is connected from the Pi Pico to the -ve rail of the breadboard.</li> <li>The red power wire is connected from the Pi Pico to the +ve rail of the breadboard.</li> </ul>"},{"location":"accelerometer/activities/motion_detection/#step-3-power-and-ground-connections","title":"Step 3: Power and Ground Connections","text":"<ul> <li>Connect the power and ground wires for the MP6050 sensor to the breadboard. The VCC pin should be connected to a 3.3V power source, and the GND pin should be connected to ground.</li> </ul> MP6050 Pin Pi Pico Pin VCC 3.3V Power Source GND Ground"},{"location":"accelerometer/activities/motion_detection/#step-4-i2csignal-connection","title":"Step 4: I2C/Signal Connection","text":"<ul> <li>Connect the I2C pins for the MP6050 sensor to the breadboard. The SCL pin should be connected to GPIO 15, and the SDA pin should be connected to GPIO 14.</li> </ul> MP6050 Pin Pi Pico Pin Colour SCL GPIO 15 Orange SDA GPIO 14 White"},{"location":"accelerometer/activities/motion_detection/#step-5-code-implementation","title":"Step 5: Code Implementation","text":"<ol> <li>Open VSCode and create a new Raspberry Pi Pico project.</li> <li>Copy the file <code>mpu6050.py</code> from the repository into your project folder.</li> <li>Create a file called main.py and add the following code: <pre><code>from mpu6050 import MPU6050\nfrom machine import Pin, I2C\nimport time\n\ntime.sleep(0.1) # Wait for USB to become ready\n\nerrorLed = Pin(19, Pin.OUT)\nokLed = Pin(18, Pin.OUT)\n\ni2c = I2C(1, sda=Pin(14), scl=Pin(15))\nmpu = MPU6050(i2c)\n\n# wake up the MPU6050 from sleep\nmpu.wake()\n\n\ntry:\n  # continuously print the data\n  while True:\n      gyro = mpu.read_gyro_data()\n      accel = mpu.read_accel_data()\n      print(\"Gyro: \" + str(gyro) + \", Accel: \" + str(accel))\n\n      if 20 &gt; gyro[0] &gt; -20:\n        okLed.high()\n        errorLed.low()\n      else:\n        okLed.low()\n        errorLed.high()\n\n      time.sleep(0.1)\nexcept:\n  pass\n</code></pre></li> </ol>"},{"location":"accelerometer/activities/motion_detection/#step-6-upload-and-run-the-code","title":"Step 6: Upload and Run the Code","text":"<ol> <li>Connect the Pi Pico to your computer via USB.</li> <li>Click on the Toggle Virtual MicroPython Workspace button to open a new VSCode window with the MicroPython workspace.</li> <li>Right click on the 'mpu6050.py' file and select 'Upload file to Pico'.</li> <li>Check that the file has been uploaded by checking the 'Mpy Remote Workspace' folder</li> <li>Select the <code>main.py</code> file and click run to execute the program on the Pi Pico.</li> </ol> <p>Note</p> <ul> <li>You will need to have followed the getting started guide to set up VSCode for Raspberry Pi Pico development.</li> </ul>"},{"location":"accelerometer/activities/motion_detection/#debugging","title":"Debugging","text":""},{"location":"accelerometer/activities/motion_detection/#mpu-wake-error","title":"MPU Wake error","text":"<ul> <li>Check that your wiring is correct and that the code Pins match your wiring.</li> </ul> <pre><code>&gt;&gt;&gt; \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 14, in &lt;module&gt;\n  File \"mpu6050.py\", line 30, in wake\nOSError: [Errno 5] EIO\n\n&gt;&gt;&gt; \n</code></pre>"},{"location":"accelerometer/activities/motion_detection/#scl-or-sda-error","title":"SCL or SDA error","text":"<ul> <li>Check that your wiring is correct and that the code Pins match your wiring. </li> <li>Check that you are using compatible I2C pins on the Pi Pico.</li> </ul> <pre><code>&gt;&gt;&gt; \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 10, in &lt;module&gt;\nValueError: bad SCL pin\n\n&gt;&gt;&gt; \n</code></pre>"},{"location":"accelerometer/activities/silent_alarm/","title":"Silent alarm","text":"<ol> <li> <p>The code below supports movement detection. When the button is pushed, it activates the accelerometer. Any slight movement after the button is pressed with trigger an alarm.</p> <ol> <li>Draw a flowchart that represents the flow and decisions of the code. Include a copy in your workbook. You can choose to draw it on paper, draw.io, lucidchart. Remember the symbols for a flowchart are:  </li> <li>Following the wokwi wiring diagram to create the silent alarm.</li> <li>Update the code and try to run the simulator. You may need to debug your simulation if it is not working.</li> </ol> <pre><code>from mpu6050 import MPU6050\nfrom machine import Pin\nimport time\n\ntime.sleep(0.1) # Wait for USB to become ready\n\n# configure the pins\nerrorLed = Pin(3, Pin.OUT)\nokLed = Pin(4, Pin.OUT)\nbutton = Pin(8, Pin.IN)\n\n# indicate if the alarm is armed\nalarm_armed = False\n\n# configure the accelerometer\ni2c = machine.I2C(1, sda=Pin(14), scl=Pin(15))\nmpu = MPU6050(i2c)\n\n# wake up the MPU6050 from sleep\nmpu.wake()\n\ndef flash_led():\n    # Flash the on led 4 times in 2 seocnds\n    for flash_count in range(8):\n        print(f'Arming the alarm {flash_count}')\n        okLed.value(flash_count % 2)\n        time.sleep(0.5)\n\ndef get_strength(mpu):\n    # Gets the combined acceleration measurement across all 3 axis as a +ve value in g\n    accel = mpu.read_accel_data()\n    return sum(abs(a) for a in accel)\n\nwhile True:\n\n    # Arm the alarm \n    if button.value() == 0:\n        alarm_armed = True\n        print('Arming the alarm')\n        flash_led()\n\n    # Check if the alarm has been triggered\n    if alarm_armed and get_strength(mpu) &gt; 0.1:\n        errorLed.high()\n        okLed.low()\n        print('Alarm Triggered')\n\n    time.sleep(0.1)\n</code></pre> </li> <li> <p>There is a bug in the solution. The alarm keeps re-arming. Change the code so that it is only armed once.</p> </li> <li>Extension: Adjust the system and code to include an alarm sound that turns off after 3 seconds. </li> </ol>"},{"location":"distance/","title":"Distance Sensors","text":"<p>Distance sensors are used to measure the distance between an object and a sensor. They are commonly used in robotics for navigation, obstacle avoidance, liquid levels, distance between the earth and the moon, objects crossing a threshold like a door way and even in air quality monitoring. Distance sensors come in many shapes and sizes, but most of them have a similar basic principle. They emit a signal and measure the time it takes for that signal to bounce back after hitting an object. This time is then converted into distance using a formula based on the speed of sound or light.</p> <p>There are many types of distance sensors available, including radar, ultrasonic sensors, infrared sensors, and LiDAR sensors. </p>"},{"location":"distance/#ultrasonic-sensors","title":"Ultrasonic Sensors","text":"<p>Ultrasonic sensors use sound waves to measure distance. They emit a high-frequency sound wave and listen for the echo that bounces back from an object. The time it takes for the sound wave to travel to the object and back is used to calculate the distance. Ultrasonic sensors are commonly used in robotics because they are accurate, reliable, and easy to use. However, they can be affected by obstacles and reflections along with soft or angled surfaces.</p> <p>In our mechatronic kits we have an SR04 ultrasonic sensor which can be used to measure distances up to 2 meters with an accuracy of about 3mm. It has two pins, Trigger and Echo pins. The Trigger pin is used to send out a pulse, while the Echo pin is used to receive the echo.</p> <p>The formula to calculate the distance using SR04 ultrasonic sensor is:</p> \\[ \\text{Distance} = \\frac{\\text{Time} \\times \\text{Speed of Sound}}{2} \\] <p>Where, Time is the time it takes for the sound wave to travel to the object and back, Speed of Sound is approximately 343 m/s at room temperature.</p> <p></p>"},{"location":"distance/#infrared-sensors","title":"Infrared Sensors","text":"<p>Infrared sensors use infrared light to measure distance. They emit a beam of infrared light and listen for the reflection that bounces back from an object. The amount of reflected light is used to calculate the distance. Infrared sensors are commonly used in robotics for obstacle avoidance and more.</p> <p>We can use IR sensors to measure speed. By connecting two IR sensors on either side of a wheel, we can measure the time it takes for the wheel to rotate. By knowing the circumference of the wheel, we can calculate the speed of the robot.</p> <p></p>"},{"location":"distance/#lidar-sensors","title":"LiDAR Sensors","text":"<p>LiDAR sensors use laser light to measure distance. They emit a beam of laser light and listen for the reflection that bounces back from an object. The amount of reflected light is used to calculate the distance. LiDAR sensors are commonly used in robotics for mapping and many of self driving applications. However, they can be affected by obstacles and reflections, along with weather conditions.</p> <p></p>"},{"location":"distance/#radar-sensors","title":"Radar Sensors","text":"<p>Radar sensors use radio waves to measure distance. They emit a beam of radio waves and listen for the reflection that bounces back from an object. The amount of reflected radio waves is used to calculate the distance. Radar sensors are commonly used in aviation, automotive and military applications. Radars were first developed during World War II and are anecdotally the reason why carrots are said to be good for your eyesight. This arose from propaganda efforts by the allies during WWII.</p>"},{"location":"distance/activity/distance_monitor/","title":"Parking Sensor","text":"<p>You have been approached to develop a parking sensor system for a car. The system should be able to detect when the car is too close to another object and provide an alert to the driver. The system should also be able to measure the distance between the car and the object. You should display varying levels of alerts based on the distance, such as \"Red\" for 10cm, \"Orange\" for 20cm, \"Yellow\" for 30cm, \"Green\" for 40cm, and \"Blue\" for 50cm. The system could also display the distance in centimetres on a digital display.</p> <p></p>"},{"location":"distance/activity/distance_monitor/#steps-to-implement","title":"Steps to Implement","text":"<p>This system is more complex than those done previously. We will build the system in stages and test each stage before moving on to the next. We will start by setting up the ultrasonic sensor and reading distance data from it.</p>"},{"location":"distance/activity/distance_monitor/#wiring-schematic","title":"Wiring Schematic","text":""},{"location":"distance/activity/distance_monitor/#step-1-components","title":"Step 1: Components","text":"<ul> <li>Ultrasonic Sensor (SR04)</li> <li>8 LED RGB Module</li> <li>1k Ohm Resistor x 1</li> <li>Passive Buzzer x 1</li> <li>NPN Transistor x 1 (S8050)</li> <li>Breadboard and Jumper Wires</li> <li>Raspberry Pi Pico</li> </ul>"},{"location":"distance/activity/distance_monitor/#step-2-setup-the-ultrasonic-sensor","title":"Step 2: Setup the Ultrasonic Sensor","text":"<p>Connect the ultrasonic sensor to the Raspberry Pi Pico according to the wiring diagram. Make sure to connect the VCC and GND pins of the sensor to a 3.3V power source on the Raspberry Pi Pico.</p> Ultrasonic Sensor Raspberry Pi Pico Colour VCC 3.3V Red GND GND Black Trig GP17 Green Echo GP16 Yellow <pre><code># Import necessary libraries\nimport time\nfrom machine import Pin\n\n# Define pins for ultrasonic sensor\ntrig = Pin(17, Pin.OUT)\necho = Pin(16, Pin.IN)\n\n# Function to measure distance\ndef measure_distance():\n    trig.value(0)\n    time.sleep_us(2)\n    trig.value(1)\n    time.sleep_us(10)\n    trig.value(0)\n    while echo.value() == 0:\n        pulse_start = time.ticks_us()\n    while echo.value() == 1:\n        pulse_end = time.ticks_us()\n    pulse_duration = time.ticks_diff(pulse_end, pulse_start)\n    distance = pulse_duration * 0.0343 / 2\n    return distance\n\n# Main loop\nwhile True:\n    distance = measure_distance()\n    print(\"Distance:\", distance, \"cm\")\n    time.sleep(1)\n</code></pre> <ul> <li>Test it out by running it on your Raspberry Pi Pico and checking the output in the serial monitor. Try waving your hand and other materials in front of the sensor to see how it measures their distance. </li> </ul> <p>Question</p> <ul> <li>Was there any material that was difficult to measure? Why do you think that is?</li> <li>Why do you think we need the sleeps in the <code>measure_distance()</code> function?</li> </ul>"},{"location":"distance/activity/distance_monitor/#step-3-setup-the-rgb-led-module","title":"Step 3: Setup the RGB LED Module","text":"<p>Connect the RGB LED module to the Raspberry Pi Pico according to the wiring diagram. Make sure to connect the VCC and GND pins of the module to a 3.3V power source on the Raspberry Pi Pico.</p> RGB LED Module Raspberry Pi Pico Colour VCC 3.3V Red GND GND Black S GP21 Brown <pre><code># Import necessary libraries\nimport time\nfrom machine import Pin\nimport neopixel\n\n# Define pins for ultrasonic sensor\ntrig = Pin(17, Pin.OUT)\necho = Pin(16, Pin.IN)\n\n# Define pin for LEDs\npixel = neopixel.NeoPixel(Pin(8, Pin.OUT), 8)\n\n# Function to set the colour of the pixel ring\ndef set_pixel_colour(colour):\n    print(f'set colour: {colour}')\n    if colour == 'Red': \n        pixel.fill((64, 0, 0))\n    elif colour == 'Yellow': \n        pixel.fill((64, 64, 0))\n    else: \n        pixel.fill((0, 64, 0))\n    pixel.write()\n\n# Function to measure distance\ndef measure_distance():\n    trig.value(0)\n    time.sleep_us(2)\n    trig.value(1)\n    time.sleep_us(10)\n    trig.value(0)\n    while echo.value() == 0:\n        pulse_start = time.ticks_us()\n    while echo.value() == 1:\n        pulse_end = time.ticks_us()\n    pulse_duration = time.ticks_diff(pulse_end, pulse_start)\n    distance = pulse_duration * 0.0343 / 2\n    return distance\n\n# Main loop\nwhile True:\n    distance = measure_distance()\n    print(\"Distance:\", distance, \"cm\")\n    time.sleep_ms(500)\n\n    if distance &lt; 5:\n        pixel.write()\n        set_pixel_colour('Red')\n    elif distance &lt; 20:\n        set_pixel_colour('Yellow')\n    else:\n        set_pixel_colour('Green')\n</code></pre> <p>Question</p> <ul> <li>Try changing the distance thresholds to see how it affects the LED colour changes.</li> <li>Experiment with different colours for the LED ring.</li> </ul>"},{"location":"distance/activity/distance_monitor/#step-4-setup-the-passive-buzzer","title":"Step 4: Setup the Passive Buzzer","text":"<p>Connect the passive buzzer to the Raspberry Pi Pico according to the wiring diagram. Make sure to connect the <code>+</code> symbol on top of it to a 3.3V power source.</p> <ul> <li>The passive buzzer has a <code>+</code> symbol on top of it. This should be connected to the 3.3V power source.</li> <li>Your kit has 2 types of transistors. We want to use the NPN one which is labelled <code>S8050</code> on the flat side of the transistor.</li> </ul> <p></p> <p>In the diagram pay attention to how the Buzzer is connected to the NPN transistor and that the 1k resistor is connected between the transistor and the signal pin (Pin 15).</p> <p>Note</p> <ul> <li>You do not need to wire up the button. It is not required for this project.</li> </ul> <pre><code># Import necessary libraries\nimport time\nimport math\nfrom machine import Pin, PWM\nimport neopixel\n\n# Define pins for ultrasonic sensor\ntrig = Pin(17, Pin.OUT)\necho = Pin(16, Pin.IN)\n\n# Define pin for LEDs\npixel = neopixel.NeoPixel(Pin(8, Pin.OUT), 8)\n\n# Define pin for buzzer\npassiveBuzzer = PWM(Pin(15, Pin.OUT))\npassiveBuzzer.freq(1000)\nPI = 3.14\n\n# Function to set the colour of the pixel ring\ndef set_pixel_colour(colour):\n    print(f'set colour: {colour}')\n    if colour == 'Red': \n        pixel.fill((64, 0, 0))\n    elif colour == 'Yellow': \n        pixel.fill((64, 64, 0))\n    else: \n        pixel.fill((0, 64, 0))\n    pixel.write()\n\n# Function to measure distance\ndef measure_distance():\n    trig.value(0)\n    time.sleep_us(2)\n    trig.value(1)\n    time.sleep_us(10)\n    trig.value(0)\n    while echo.value() == 0:\n        pulse_start = time.ticks_us()\n    while echo.value() == 1:\n        pulse_end = time.ticks_us()\n    pulse_duration = time.ticks_diff(pulse_end, pulse_start)\n    distance = pulse_duration * 0.0343 / 2\n    return distance\n\ndef sound_distance():\n    print('Make sound')\n    passiveBuzzer.duty_u16(2*4092)\n    for x in range(0, 36):\n        sinVal = math.sin(x * 10 * PI / 180)\n        toneVal = 1500 + int(sinVal * 500)\n        passiveBuzzer.freq(toneVal)\n        time.sleep_ms(10)\n\n# Main loop\nwhile True:\n    distance = measure_distance()\n    print(\"Distance:\", distance, \"cm\")\n    time.sleep_ms(500)\n\n    if distance &lt; 5:\n        pixel.write()\n        set_pixel_colour('Red')\n        sound_distance()\n    elif distance &lt; 20:\n        set_pixel_colour('Yellow')\n        passiveBuzzer.duty_u16(0)\n    else:\n        set_pixel_colour('Green')\n        passiveBuzzer.duty_u16(0)\n</code></pre> <p>Question</p> <ul> <li>Can you make the sound more like what you hear when a car is reversing. That is the sound should happen more quickly and not sound like an alarm?</li> </ul>"},{"location":"electronics/","title":"Introduction to Electronics","text":"<p>This section covers the basics of electronics, including circuits, components, and common electronic devices. It also introduces some basic programming concepts that are useful for working with electronics.</p>"},{"location":"electronics/#circuits","title":"Circuits","text":"<p>A circuit is a closed loop through which electric current can flow. The most basic type of circuit consists of a power source (such as a battery), a load (such as a light bulb or motor), and a conductor (such as a wire).</p>"},{"location":"electronics/#components","title":"Components","text":"<p>There are many different types of electronic components, each with its own specific function. Some common examples include resistors, capacitors, transistors, and integrated circuits.</p>"},{"location":"electronics/#resistors","title":"Resistors","text":"<p>A resistor is a passive component that resists the flow of electric current. The resistance of a resistor is measured in ohms (\u03a9). Resistors can be used to limit the amount of current flowing through a circuit, or to divide an input voltage into smaller voltages.</p>"},{"location":"electronics/#capacitors","title":"Capacitors","text":"<p>A capacitor is a passive component that stores electrical energy in an electric field. The capacitance of a capacitor is measured in farads (F). Capacitors can be used to filter out high-frequency noise from a signal, or to store energy for later use.</p>"},{"location":"electronics/#transistors","title":"Transistors","text":"<p>A transistor is a semiconductor device that amplifies or switches electronic signals. Transistors are used in a wide range of applications, including amplifiers, oscillators, and logic circuits.</p>"},{"location":"electronics/#diodes","title":"Diodes","text":"<p>A diode is a semiconductor device that allows current to flow in one direction, but blocks it from flowing in the opposite direction. Diodes are used in a wide range of applications, including rectifiers, switches, and voltage regulators.</p>"},{"location":"electronics/#leds","title":"LEDs","text":"<p>An LED (Light Emitting Diode) is a semiconductor device that emits light when an electric current flows through it. LEDs are used in a wide range of applications, including displays, indicators, and lighting.</p>"},{"location":"electronics/#2-way-switches","title":"2-way Switches","text":"<p>A 2-way switch is a device that allows two different paths for current to flow. It is used in a wide range of applications, including lighting control and power distribution.</p>"},{"location":"electronics/#onoff-switches","title":"On/Off Switches","text":"<p>An on/off switch is a device that allows current to flow in one direction, but blocks it from flowing in the opposite direction. On/off switches are used in a wide range of applications, including lighting control and power distribution.</p>"},{"location":"electronics/#speakers","title":"Speakers","text":"<p>A speaker is an electronic device that converts electrical signals into sound waves. Speakers are used in a wide range of applications, including audio systems and communication devices.</p>"},{"location":"electronics/#motors","title":"Motors","text":"<p>A motor is an electronic device that converts electrical energy into mechanical energy. Motors are used in a wide range of applications, including transportation, industrial automation, and home appliances.</p>"},{"location":"electronics/#amplifiers","title":"Amplifiers","text":"<p>An amplifier is an electronic device that increases the amplitude of an electrical signal. Amplifiers are used in a wide range of applications, including audio systems and communication devices.</p>"},{"location":"electronics/#voltage-sources","title":"Voltage Sources","text":""},{"location":"electronics/#integrated-circuits","title":"Integrated Circuits","text":"<p>An integrated circuit (IC) is a small chip that contains many transistors and other components on a single piece of silicon. ICs are used to create complex electronic systems with high performance and low cost.</p>"},{"location":"electronics/#common-electronic-devices","title":"Common Electronic Devices","text":"<p>Some common electronic devices include micro-controllers, sensors, and actuators. Micro-controllers are small computers that can be programmed to perform a variety of tasks. Sensors are devices that measure physical quantities such as temperature or light intensity. Actuators are devices that convert electrical signals into mechanical motion.</p>"},{"location":"led/led/","title":"Light Emitting Diode (LED)","text":"<p>An LED is a type of diode. All diodes only work if current is flowing in the correct direction and have two Poles. </p> <p>An LED will only work (light up) if the longer pin (+) of LED is connected to the positive output from a power source and the shorter pin is connected to the negative (-). Negative output is also referred to as Ground (GND). This type of component is known as \u201cPolar\u201d (think One-Way Street).</p> <p>All common two-lead diodes are the same in this respect. Diodes work only if the voltage of its positive electrode is higher than that of its negative electrode, and there is a narrow range of operating voltages for most common diodes, typically between 1.9V and 3.4V. If you use much more than 3.3V the LED will be damaged and burn out</p> <p></p>"},{"location":"led/activities/blinky/","title":"Blinking LED","text":""},{"location":"led/activities/blinky/#introduction","title":"Introduction","text":"<p>The blinking LED is a classic example used to demonstrate the basic functionality of microcontrollers. It involves toggling an LED on and off repeatedly, which can be achieved using simple programming logic.</p>"},{"location":"led/activities/blinky/#components","title":"Components","text":"<ul> <li>Raspberry Pi Pico W</li> <li>Breadboard</li> <li>Jumper wires</li> <li>Red LED</li> <li>220 ohm resistor</li> <li>USB Cable</li> </ul>"},{"location":"led/activities/blinky/#onboard-led","title":"Onboard LED","text":"<p>The Raspberry Pi Pico W has an onboard LED connected to GPIO 25. This LED can be used for basic testing and debugging purposes.</p> <ol> <li>Connect the Pico W to your computer using a USB cable.</li> <li>Open VS Code and start a new Pico Project</li> <li>In the main.py file, add the code</li> </ol> <pre><code>from machine import Pin\nimport time\n\nled = Pin('LED', Pin.OUT)\ntry:\nwhile True:\n    led.value(1)\n    time.sleep(0.5)\n    led.value(0)\n    time.sleep(0.5)\nexcept:\n    pass\n</code></pre> <ol> <li>Run the code on your Pico W by clicking the \"Run\" button in VS Code at the bottom of the IDE.</li> <li> <p>Upload the code to your Pico W and observe the onboard LED blinking.</p> </li> <li> <p>Try making the LED blink faster or slower by changing the sleep duration.</p> </li> </ol>"},{"location":"led/activities/blinky/#external-led","title":"External LED","text":"<pre><code>from machine import Pin\nimport time\n\nled = Pin(15, Pin.OUT)\ntry:\nwhile True:\n    led.value(1)\n    time.sleep(0.5)\n    led.value(0)\n    time.sleep(0.5)\nexcept:\n    pass\n</code></pre> <ul> <li>Try connecting more and or different coloured LEDs</li> <li>See of you can create a chaser sequence with multiple LEDs.<ul> <li>A chaser is when one LED turns on, then the next, then the next until all are lit up in sequence before starting again.</li> </ul> </li> </ul>"},{"location":"servo/","title":"Servo Motors","text":""},{"location":"servo/#1-introduction-to-pulse-width-modulation-pwm","title":"1. Introduction to Pulse Width Modulation (PWM)","text":"<p>Pulse Width Modulation (PWM) is a technique used to encode information or control the amount of power delivered to a device by varying the width of pulses in a periodic signal. In simpler terms, PWM rapidly switches a digital signal between on (HIGH) and off (LOW) states at a specific frequency, with the ratio of \"on time\" to \"total time\" (known as duty cycle) determining the average power delivered.</p> <p></p>"},{"location":"servo/#key-pwm-concepts","title":"Key PWM Concepts:","text":"<ul> <li>Period: The time it takes for one complete cycle (measured in seconds or milliseconds)</li> <li>Frequency: The number of complete cycles per second (measured in Hertz, Hz)</li> <li>Duty Cycle: The percentage of time the signal is HIGH during one period</li> <li>Pulse Width: The duration of the HIGH state (measured in microseconds for servos)</li> </ul>"},{"location":"servo/#uses-of-pwm-in-electronics","title":"Uses of PWM in Electronics:","text":"<p>PWM is used in micro-controller boards because they can only produce digital (on or off) voltage pulses rather than continuous analog voltage. PWM effectively simulates an analog output by switching rapidly between on and off states.</p> <p>Common uses of PWM include:</p> <ul> <li>Controlling motor speed (DC motors)</li> <li>Controlling servo position (standard 180\u00b0 servos)</li> <li>Controlling servo speed and direction (continuous rotation servos)</li> <li>LED brightness control</li> <li>Audio generation</li> <li>Power regulation</li> </ul> <p>PWM is a clever solution that allows digital systems to control analog devices by using the duration (width) of digital pulses rather than varying the voltage directly.</p>"},{"location":"servo/#2-types-of-servo-motors","title":"2. Types of Servo Motors","text":"<p>There are two main types of servo motors commonly used in electronics and robotics projects: standard 180\u00b0 servos and continuous rotation servos. Each has distinct characteristics and applications.</p>"},{"location":"servo/#21-standard-180-servo-motors","title":"2.1 Standard 180\u00b0 Servo Motors","text":"<p>Standard 180\u00b0 servo motors are designed to rotate to specific angular positions within a 180-degree range. These are the most common type of servos used in hobbyist electronics, robotics, and RC applications.</p>"},{"location":"servo/#key-characteristics","title":"Key Characteristics:","text":"<ul> <li>Limited rotational range (typically 0\u00b0 to 180\u00b0)</li> <li>Precise positional control</li> <li>Ability to hold a specific angle against opposing forces</li> <li>Built-in position feedback (via potentiometer)</li> </ul>"},{"location":"servo/#components-of-a-180-servo-motor","title":"Components of a 180\u00b0 Servo Motor:","text":"<ul> <li>DC motor (provides the rotational power)</li> <li>Gearbox (for torque amplification and speed reduction)</li> <li>Potentiometer (for position feedback)</li> <li>Control circuit (interprets PWM signals)</li> </ul> <p>A servo motor has a 'closed-loop' control system that uses feedback to control its position. The potentiometer is attached to the output axle and as the axle turns, it changes the voltage delivered to the control circuit. This voltage is proportional to the rotation of the gear and can be measured against the voltage originally sent to the servo, causing the motor to rotate until the two match.</p>"},{"location":"servo/#22-continuous-rotation-servos","title":"2.2 Continuous Rotation Servos","text":"<p>Unlike standard servos, continuous rotation servos are modified to allow complete 360\u00b0 rotation. They're essentially a hybrid between a standard servo and a geared DC motor.</p>"},{"location":"servo/#key-characteristics_1","title":"Key Characteristics:","text":"<ul> <li>Unlimited rotation in either direction</li> <li>Speed and direction control (rather than position control)</li> <li>Usually no position feedback</li> <li>Same form factor and control interface as standard servos</li> </ul>"},{"location":"servo/#how-continuous-rotation-servos-differ","title":"How Continuous Rotation Servos Differ:","text":"<ul> <li>The potentiometer is either removed or fixed in the center position</li> <li>The mechanical stops are removed to allow full rotation</li> <li>PWM signals control speed and direction rather than position</li> <li>1.5ms pulse (neutral) stops the servo</li> <li>&lt;1.5ms pulses rotate in one direction (faster as pulse width decreases)</li> <li>&gt;1.5ms pulses rotate in the other direction (faster as pulse width increases)</li> </ul>"},{"location":"servo/#3-how-servos-interpret-pwm-signals","title":"3. How Servos Interpret PWM Signals","text":""},{"location":"servo/#31-pwm-control-for-180-servos","title":"3.1 PWM Control for 180\u00b0 Servos","text":"<p>Standard 180\u00b0 servos use PWM signals to determine their position. The width of the pulse tells the servo where to position its shaft:</p> <ul> <li>1.0ms pulse width (1000\u03bcs): Moves to 0\u00b0 position</li> <li>1.5ms pulse width (1500\u03bcs): Moves to 90\u00b0 position (center)</li> <li>2.0ms pulse width (2000\u03bcs): Moves to 180\u00b0 position</li> </ul> <p>Most servos expect these pulses to be sent at a frequency of 50Hz, which means a period of 20ms (\\(1 second \u00f7 50 = 0.02 seconds\\) or 20ms).</p> <p></p>"},{"location":"servo/#32-pwm-control-for-continuous-rotation-servos","title":"3.2 PWM Control for Continuous Rotation Servos","text":"<p>For continuous rotation servos, the PWM signal controls speed and direction rather than position:</p> <ul> <li>1.5ms pulse width (1500\u03bcs): No rotation (stop)</li> <li>&lt; 1.5ms pulse width: Clockwise rotation (shorter pulse = faster rotation)</li> <li>&gt; 1.5ms pulse width: Counter-clockwise rotation (longer pulse = faster rotation)</li> </ul> <p>At the extremes:</p> <ul> <li>1.0ms pulse width: Maximum speed in clockwise direction</li> <li>2.0ms pulse width: Maximum speed in counter-clockwise direction</li> </ul> <p>The control principle is similar to standard servos, but the interpretation of the signal is different. Instead of moving to a position, the continuous rotation servo will rotate at a speed proportional to how far the pulse width is from the neutral 1.5ms point.</p>"},{"location":"servo/#3-pwm-calculations-and-duty-cycle","title":"3. PWM Calculations and Duty Cycle","text":"<p>To control a servo using PWM, we need to understand how to calculate the appropriate duty cycle:</p>"},{"location":"servo/#formula","title":"Formula:","text":"<pre><code>Duty Cycle (%) = (Pulse Width / Period) \u00d7 100%\n</code></pre> <p>For a servo with a 50Hz signal (20ms period):</p> <ul> <li>1ms pulse = (1ms / 20ms) \u00d7 100% = 5% duty cycle (0\u00b0 position)</li> <li>1.5ms pulse = (1.5ms / 20ms) \u00d7 100% = 7.5% duty cycle (90\u00b0 position)</li> <li>2ms pulse = (2ms / 20ms) \u00d7 100% = 10% duty cycle (180\u00b0 position)</li> </ul> <p>The width of the pulse is called its \"duty cycle\" (expressed as a percentage). This determines the rotational position of the servo shaft. The duty cycle represents the ratio of \"on time\" to \"total time\" in each PWM cycle.</p> <p>Microcontroller boards (like the Raspberry Pi Pico or micro:bit) use PWM to control servos because they can only produce digital (on or off) voltage pulses rather than continuous analog voltage. While regular DC motors work well with continuous voltage, servos need precisely timed pulses to determine their position.</p>"},{"location":"servo/#4-controlling-servos-with-raspberry-pi-pico","title":"4. Controlling Servos with Raspberry Pi Pico","text":""},{"location":"servo/#41-controlling-a-standard-180-servo","title":"4.1 Controlling a Standard 180\u00b0 Servo","text":"<p>The Raspberry Pi Pico has dedicated hardware PWM channels that can be used to control servos with high precision.</p>"},{"location":"servo/#micropython-implementation","title":"MicroPython Implementation:","text":"<pre><code>from machine import Pin, PWM\nimport time\n\n# Create a PWM object on GPIO pin 0\nservo = PWM(Pin(0))\n\n# Set the PWM frequency to 50Hz (standard for servos)\nservo.freq(50)\n\n# Function to set the servo angle (0-180 degrees)\ndef set_angle(angle):\n    # Convert angle to duty cycle (0.5ms to 2.5ms)\n    # Maps angle 0-180 to duty values 1638-8192\n    # 16-bit resolution means max duty value is 65535\n    duty = int(1638 + (angle / 180) * 6554)\n    servo.duty_u16(duty)\n\n# Move servo to different positions\nset_angle(0)    # 0 degrees\ntime.sleep(1)\nset_angle(90)   # 90 degrees\ntime.sleep(1)\nset_angle(180)  # 180 degrees\ntime.sleep(1)\n\n# Center position\nset_angle(90)\n</code></pre>"},{"location":"servo/#42-controlling-a-continuous-rotation-servo","title":"4.2 Controlling a Continuous Rotation Servo","text":"<p>For continuous rotation servos, we control speed and direction rather than position:</p> <pre><code>from machine import Pin, PWM\nimport time\n\n# Create a PWM object on GPIO pin 0\ncont_servo = PWM(Pin(0))\n\n# Set the PWM frequency to 50Hz (standard for servos)\ncont_servo.freq(50)\n\n# Function to set the continuous servo speed (-100 to +100)\n# -100 = maximum speed in one direction\n# 0 = stop\n# +100 = maximum speed in the other direction\ndef set_speed(speed):\n    # Convert speed (-100 to +100) to duty cycle\n    # 1.5ms (center/stop) is approximately 4915 in 16-bit duty\n    # We'll vary by about +/- 1638 from this center point\n    center_duty = 4915\n    duty = int(center_duty + (speed / 100) * 1638)\n    cont_servo.duty_u16(duty)\n\n# Example usage\nset_speed(0)      # Stop\ntime.sleep(2)\nset_speed(50)     # Half speed in one direction\ntime.sleep(2)\nset_speed(0)      # Stop\ntime.sleep(1)\nset_speed(-75)    # 75% speed in the other direction\ntime.sleep(2)\nset_speed(0)      # Stop\n</code></pre>"},{"location":"servo/#understanding-the-duty-value-calculation","title":"Understanding the Duty Value Calculation:","text":"<p>The Raspberry Pi Pico PWM has a 16-bit resolution, meaning duty cycles range from 0 to 65535.</p> <p>For a 50Hz signal with a period of 20ms:</p> <ul> <li>1ms pulse (0\u00b0 for standard servo or max speed in one direction for continuous) corresponds to: (1ms / 20ms) \u00d7 65535 \u2248 3277</li> <li>1.5ms pulse (90\u00b0 or stop) corresponds to: (1.5ms / 20ms) \u00d7 65535 \u2248 4915</li> <li>2ms pulse (180\u00b0 or max speed in other direction) corresponds to: (2ms / 20ms) \u00d7 65535 \u2248 6554</li> </ul> <p>In practice, you may need to adjust these values slightly depending on your specific servo.</p>"},{"location":"servo/#5-common-issues-and-troubleshooting","title":"5. Common Issues and Troubleshooting","text":""},{"location":"servo/#servo-jitter","title":"Servo Jitter","text":"<ul> <li>Cause: Inconsistent PWM signal or noise</li> <li>Solution: Add a capacitor (100-470\u03bcF) across the servo's power connections</li> </ul>"},{"location":"servo/#limited-range","title":"Limited Range","text":"<ul> <li>Cause: Incorrect pulse width range</li> <li>Solution: Adjust min/max pulse width values in your code</li> </ul>"},{"location":"servo/#power-issues","title":"Power Issues","text":"<ul> <li>Cause: Insufficient current supply</li> <li>Solution: Use a separate power supply for servos, especially when using multiple servos</li> </ul>"},{"location":"servo/#servo-stutter-or-trembling","title":"Servo Stutter or Trembling","text":"<p>Hobby servos sometimes 'tremble' or 'stutter' if they do not have sufficient voltage. This happens because the control circuit is constantly trying to match the feedback from the potentiometer with the desired position. If the power supply is insufficient, the motor may not have enough torque to hold the position steadily.</p>"},{"location":"servo/#limited-motion","title":"Limited Motion","text":"<p>Most hobby servos are typically limited to 180 degrees of motion, although some servos are capable of 360-degree rotation. This limitation is due to the mechanical constraints of the feedback potentiometer.</p>"},{"location":"servo/#6-practical-applications","title":"6. Practical Applications","text":""},{"location":"servo/#61-applications-of-180-servos","title":"6.1 Applications of 180\u00b0 Servos","text":"<p>Standard 180\u00b0 servo motors are used in a wide range of mechatronic applications:</p> <ul> <li>Robotics: Joint control, gripper mechanisms, robotic arms</li> <li>Camera Systems: Pan/tilt mechanisms, focus control, gimbal stabilisation</li> <li>RC Vehicles: Steering, throttle control</li> <li>Automated Systems: Valve control, switches</li> <li>Accessibility Solutions: Automatic door openers (as shown in the Skill Builder project)</li> <li>Drone Technology: Keeping cameras level and stabilised</li> <li>Smart Home Automation: Window and door openers, climate control actuators</li> <li>Precision Equipment: Position control for various mechanical systems</li> </ul>"},{"location":"servo/#example-application-accessible-automatic-door","title":"Example Application: Accessible Automatic Door","text":"<p>A practical application using an ultrasonic distance sensor and a 180\u00b0 servo motor to create an accessible automatic door:</p> <ol> <li>When a person or object gets closer than 10 centimetres from the sensor, the door opens (servo rotates to specific position)</li> <li>When the distance is greater than 10 centimetres, the door closes (servo returns to original position)</li> <li>This simple but effective system could assist people with mobility challenges</li> </ol>"},{"location":"servo/#62-applications-of-continuous-rotation-servos","title":"6.2 Applications of Continuous Rotation Servos","text":"<p>Continuous rotation servos are ideal for applications requiring controlled rotational motion rather than specific positioning:</p> <ul> <li>Wheeled Robots: Drive wheels for small robots where controlled speed is important</li> <li>Conveyor Systems: Small-scale conveyor belts with variable speed control</li> <li>Rotating Platforms: Turntables, rotating displays, or scanning platforms</li> <li>Winch Mechanisms: For pulling or lifting with controlled speed</li> <li>Mixing Applications: Controlled stirring or mixing in maker projects</li> <li>Motorised Camera Sliders: Creating smooth panning motion for timelapse photography</li> <li>Fan or Propeller Control: Where variable speed is needed</li> </ul>"},{"location":"servo/#example-application-line-following-robot","title":"Example Application: Line-Following Robot","text":"<p>A line-following robot can use continuous rotation servos for its wheels:</p> <ol> <li>When the robot needs to follow a straight line, both continuous servos rotate at the same speed</li> <li>When the robot needs to turn, the speeds of the servos are adjusted relative to each other</li> <li>The PWM signal can precisely control the speed of each wheel, allowing for smooth navigation</li> </ol> <p>Note</p> <p>DC Motors are a better choice for driving line-following robots due to their ability to provide more torque and better speed control. </p>"},{"location":"servo/#7-comparing-servo-types-and-other-motors","title":"7. Comparing Servo Types and Other Motors","text":""},{"location":"servo/#71-standard-180-servos-vs-continuous-rotation-servos","title":"7.1 Standard 180\u00b0 Servos vs. Continuous Rotation Servos","text":"Feature 180\u00b0 Servo Continuous Rotation Servo Rotation Range Limited (0-180\u00b0) Unlimited (360\u00b0 continuous) Control Parameter Position Speed and direction Feedback Position feedback via potentiometer Typically no position feedback Holding Position Can hold a specific angle Cannot hold position (only stop) Applications Precise positioning, RC control Wheeled robots, continuous motion PWM Control Pulse width determines angle Pulse width determines speed &amp; direction Common Use Case Moving to specific angles Continuous rotation at controlled speeds"},{"location":"servo/#72-servo-motors-vs-dc-motors-vs-stepper-motors","title":"7.2 Servo Motors vs. DC Motors vs. Stepper Motors","text":"<p>These three types of motors are used differently in mechatronics:</p> <p>DC Motors: - Provide smooth, continuous rotational motion in clockwise and counterclockwise directions - Open-loop system (input current is not affected by output rotation) - Used in most battery-powered moving toys - Constructed with many windings of copper wire around a rotor</p> <p>Standard Servo Motors: - Provide continuous angular movement to a specific location, often 0 to 180 degrees - Use closed-loop control with feedback and high torque at low speeds - Lower power needed compared to stepper motors - The output shaft is linked through a potentiometer for position feedback - Common in focusing for cameras, window and door openers, robotic arms, and RC vehicles</p> <p>Continuous Rotation Servos: - Hybrid between standard servos and geared DC motors - Same form factor and control interface as standard servos - Provides continuous rotation with speed control - Often used in robotic wheels, conveyor systems, and other continuous motion applications</p> <p>Stepper Motors: - Provide precise stepped angular movement using feedback control - High torque at high speeds - Higher power needed - Used in automated systems requiring precise movements (like 3D printers) - The shaft can be commanded to move and hold at specific step positions without feedback</p>"},{"location":"servo/#8-wiring-diagram-for-raspberry-pi-pico-and-sg90-servo","title":"8. Wiring Diagram for Raspberry Pi Pico and SG90 Servo","text":"Raspberry Pi Pico SG90 Servo VBUS (5V) Red wire (Power) GND Brown wire (Ground) GPIO 0 Orange wire (Signal)"},{"location":"servo/#9-control-systems-with-servos","title":"9. Control Systems with Servos","text":"<p>Servos are especially valuable in control systems, particularly in closed-loop control systems. In a closed-loop system, feedback is used to adjust the output dynamically.</p>"},{"location":"servo/#open-loop-vs-closed-loop-control","title":"Open-Loop vs. Closed-Loop Control","text":"<p>Open-Loop Systems:</p> <ul> <li>Do not use feedback</li> <li>Example: A regular DC motor where input current is not affected by its output rotation</li> <li>Simpler but less precise</li> </ul> <p>Closed-Loop Systems:</p> <ul> <li>Use feedback to continuously adjust the output</li> <li>Example: A servo motor where the output shaft is linked through a potentiometer</li> <li>More complex but provide precise positioning</li> </ul>"},{"location":"servo/#practical-application-self-levelling-platform","title":"Practical Application: Self-Levelling Platform","text":"<p>A practical application where a servo and accelerometer sensor create a self-levelling platform:</p> <ul> <li>The accelerometer measures the tilt of a platform</li> <li>The servo rotates in the opposite direction to maintain a level position</li> <li>This creates a stabilising gimbal effect, similar to those used for camera stabilisation</li> </ul>"},{"location":"servo/#10-summary","title":"10. Summary","text":"<p>PWM is a powerful technique for controlling servo motors by varying pulse widths to specify precise angular positions. For a standard 180\u00b0 servo:</p> <ul> <li>Frequency: 50Hz (20ms period)</li> <li>Pulse width: 1.0ms to 2.0ms (corresponds to 0\u00b0 to 180\u00b0)</li> <li>Duty cycle: Approximately 5% to 10% for full range</li> </ul> <p>With the Raspberry Pi Pico's built-in PWM capabilities, controlling servos becomes straightforward through MicroPython's PWM library, allowing for precise positioning in a variety of applications.</p> <p>Servos are a key component in mechatronic systems where precise position control is required. Unlike regular DC motors, they incorporate feedback mechanisms that allow them to maintain a specific position, making them ideal for applications ranging from robotic arms to automated doors and precision control systems.</p>"},{"location":"servo/#11-conclusion","title":"11. Conclusion","text":"<p>PWM is a powerful technique for controlling both standard 180\u00b0 servo motors and continuous rotation servos. Understanding the differences between these servo types is essential for selecting the right motor for your application:</p> <ul> <li> <p>Standard 180\u00b0 servos excel at precise positioning tasks where you need to move to and hold specific angles. Their built-in feedback mechanism makes them ideal for robotic arms, camera systems, and other applications requiring positional accuracy.</p> </li> <li> <p>Continuous rotation servos are perfect for applications requiring continuous motion with speed control. They're essentially a hybrid between a standard servo and a geared DC motor, making them ideal for wheeled robots and other projects requiring controlled continuous rotation.</p> </li> </ul> <p>Both types of servos use the same PWM control principle, but interpret the signals differently: - For 180\u00b0 servos, pulse width determines angular position - For continuous rotation servos, pulse width determines rotational speed and direction</p> <p>With the Raspberry Pi Pico's built-in PWM capabilities, controlling either type of servo becomes straightforward through MicroPython's PWM library, allowing for precise control in a variety of applications.</p> <p>The choice between a standard or continuous rotation servo depends entirely on your specific project requirements. For some applications, you might even use both types together - standard servos for positioning components and continuous rotation servos for driving wheels or conveyor systems.</p>"},{"location":"servo/#12-additional-resources","title":"12. Additional Resources","text":"<ul> <li>Raspberry Pi Pico Documentation</li> <li>SG90 Servo Datasheet</li> <li>MicroPython PWM Documentation</li> <li>Servo Motor Basics Tutorial</li> </ul>"},{"location":"webserver/","title":"Webserver","text":"<p>We are going to develop a visually appealing web server on the Pico W using Phew and Bootstrap. </p> <p>This activity is to be completed in pairs. You need 2 computers to complete this activity.</p>"},{"location":"webserver/#phew","title":"Phew","text":"<p>Phew!, developed by Pimoroni for their Enviro range, is designed to create captive Wi-Fi hotspots with a user-friendly web interface for device setup. It functions perfectly on Pico W boards and most other MicroPython devices, though it is tailored mainly for Pico W. Besides a reliable built-in web server, Phew! offers great features like logging and an easy-to-use templating system, simplifying the development of interactive websites.</p> <ul> <li>Phew documentation</li> <li>Phew Code</li> </ul>"},{"location":"webserver/#steps","title":"Steps","text":"<p>This code sets up a web server that can be accessed via the Pico W's IP address. The server has two routes: \"/\" and \"/\". When you navigate to \"/\", it displays the HTML content of \"index.html\". When you navigate to \"/\", it turns on or off an LED based on the command provided. <p>Step 1. Download all files in the Phew Code github repository.</p> <p>Step 2. Create a folder on your Pico W called <code>/lib/phew</code> and copy all files from step 1 into the folder</p> <p>Step 3. Create a file called <code>index.html</code> and add the following code to it</p> <pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Pico W Web Server&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"icon\" href=\"data:,\"&gt;\n    &lt;style&gt;\n        html {\n            font-family: Helvetica;\n            display: inline-block;\n            margin: 0px auto;\n            text-align: center;\n        }\n\n        h1 {\n            color: #0F3376;\n            padding: 2vh;\n        }\n\n        p {\n            font-size: 1.5rem;\n        }\n\n        button {\n            display: inline-block;\n            background-color: #4286f4;\n            border: none;\n            border-radius: 4px;\n            color: white;\n            padding: 16px 40px;\n            text-decoration: none;\n            font-size: 30px;\n            margin:\n                2px;\n            cursor: pointer;\n        }\n\n        button2 {\n            background-color: #4286f4;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;h1&gt;Pico W Web Server&lt;/h1&gt;\n    &lt;p&gt;GPIO state: &lt;strong&gt;gpio_state&lt;/strong&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;a href=\"/on\"&gt;&lt;button class=\"button\"&gt;ON&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;a href=\"/off\"&gt;&lt;button class=\"button button2\"&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Step 4. Create a file called <code>main.py</code> and paste the following code into it:</p> <pre><code>from phew import server, access_point\nimport machine\n\nwifi = access_point(\"My-Access-Point-Beverley\",\"1234567890\")\n</code></pre> <ul> <li>This code imports the necessary modules and creates an access point for your Pico W. <ul> <li><code>My-Access-Point-Beverley</code> is the SSID of the access point </li> <li><code>1234567890</code> is the password</li> </ul> </li> </ul> <p>Note</p> <p>You should change the SSID and password to something unique that you and your partner agree on.</p> <pre><code>page = open(\"index.html\",\"r\")\nhtml= page.read()\npage.close()\n</code></pre> <ul> <li>This code reads the HTML content of \"index.html\" and stores it in a variable called <code>html</code>.</li> </ul> <pre><code>led = machine.Pin(\"LED\", machine.Pin.OUT)\n\ndef gpio_state():\n    if led.value() == 1:\n        return 'On'\n    else:\n        return 'Off'\n</code></pre> <ul> <li>This code creates a pin object for the onboard LED on your Pico W.</li> <li>Define a function called <code>gpio_state</code> that returns the current state of the LED. If the LED is on, it returns 'On'. Otherwise, it returns 'Off'.</li> </ul> <pre><code>@server.route(\"/\", methods=[\"GET\"])\ndef home(request):\n    return str(html)\n</code></pre> <ul> <li>This code defines a route for the home. A route is a URL that can be accessed by the user. In this case, the route is \"/\".</li> </ul> <pre><code>@server.route(\"/on\", methods=[\"GET\"])\ndef on_command(request):\n    led.on()\n    return str(html).replace('gpio_state', gpio_state())\n\n@server.route(\"/off\", methods=[\"GET\"])\ndef off_command(request):\n    led.off()\n    return str(html).replace('gpio_state', gpio_state())\n</code></pre> <ul> <li>This code defines routes for turning the LED on and off. The <code>&lt;command&gt;</code> part of the URL is a variable that can be accessed by the function. In this case, if the user goes to \"/on\", the LED will turn on. If the user goes to \"/off\", the LED will turn off.</li> </ul> <pre><code>@server.catchall()\ndef catchall(request):\n    return \"Page not found\", 404\n</code></pre> <ul> <li>This code defines a route for any other URL that is not defined above. If the user goes to a URL that is not defined, it will return \"Page not found\".</li> </ul> <pre><code>server.run()\n</code></pre> <ul> <li>This code starts the server. The server will listen for incoming requests on port 8080.</li> </ul> <p>Question</p> <ul> <li>What other features could be added to this webserver?</li> <li>How could you use this to display a dashboard of sensor data?</li> <li>How could you add authentication to this webserver?</li> <li>Try and adapt the webserver code to work with one of the sensors or displays in your kit.</li> </ul>"}]}